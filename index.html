<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fisherian Runaway Random Chess</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
            color: #333;
            padding: 20px;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .game-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            max-width: 1200px;
            justify-content: center;
        }
        
        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            border: 2px solid #333;
            margin-bottom: 10px;
        }
        
        .cell {
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            cursor: pointer;
            position: relative;
            user-select: none;
        }
        
        .white {
            background-color: #f0d9b5;
        }
        
        .black {
            background-color: #b58863;
        }
        
        .selected {
            background-color: rgba(173, 216, 230, 0.7);
        }
        
        .valid-move {
            position: relative;
        }
        
        .valid-move::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: rgba(0, 128, 0, 0.5);
            border-radius: 50%;
            z-index: 1;
        }
        
        .piece {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .piece-stats {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .control-panel {
            width: 300px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .info-panel {
            width: 100%;
            max-width: 600px;
            margin-top: 20px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .piece-info {
            margin-top: 20px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }
        
        .turn-indicator {
            font-size: 18px;
            font-weight: bold;
            margin: 10px 0;
            color: #2c3e50;
        }
        
        .evolution-history {
            max-height: 150px;
            overflow-y: auto;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 14px;
        }
        
        .game-log {
            max-height: 150px;
            overflow-y: auto;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 14px;
        }

        .generation-indicator {
            font-size: 16px;
            margin: 10px 0;
        }

        .evolution-bar {
            width: 100%;
            height: 20px;
            background-color: #ddd;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }

        .evolution-progress {
            height: 100%;
            background-color: #4CAF50;
            border-radius: 10px;
            width: 0%;
            transition: width 0.5s;
        }
    </style>
</head>
<body>
    <h1>Fisherian Runaway Random Chess</h1>
    <p>Where pieces evolve through sexual selection and random mutations!</p>
    
    <div class="game-container">
        <div class="board-container">
            <div class="turn-indicator" id="turnIndicator">White's Turn</div>
            <div class="chess-board" id="chessBoard"></div>
            <div class="generation-indicator">Generation: <span id="generationCounter">1</span></div>
            <div class="evolution-bar">
                <div class="evolution-progress" id="evolutionProgress"></div>
            </div>
        </div>
        
        <div class="control-panel">
            <h2>Control Panel</h2>
            <button id="newGameBtn">New Game</button>
            <button id="evolveBtn" disabled>Evolve Pieces (after 10 moves)</button>
            <div class="piece-info" id="pieceInfo">
                <p>Select a piece to see its attributes</p>
            </div>
            <h3>Evolution History</h3>
            <div class="evolution-history" id="evolutionHistory">
                <p>Game started. Pieces have base attributes.</p>
            </div>
        </div>
    </div>
    
    <div class="info-panel">
        <h2>Game Log</h2>
        <div class="game-log" id="gameLog">
            <p>Game started. White to move.</p>
        </div>
        
        <h2>How to Play</h2>
        <p>This is chess with evolving pieces:</p>
        <ul>
            <li>Every piece has hidden attributes that affect its movement and capture abilities.</li>
            <li>After every 10 moves, pieces can "evolve" through Fisherian selection.</li>
            <li>When pieces capture others, they can gain some of their characteristics.</li>
            <li>Random mutations can occur, leading to runaway traits (exaggerated abilities).</li>
            <li>The goal is still to checkmate the opponent's king, but with unpredictable piece behaviors!</li>
        </ul>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Game state
            let selectedPiece = null;
            let validMoves = [];
            let currentTurn = 'white';
            let moveCount = 0;
            let generation = 1;
            
            // Board and pieces setup
            const board = document.getElementById('chessBoard');
            const pieceInfo = document.getElementById('pieceInfo');
            const gameLog = document.getElementById('gameLog');
            const evolutionHistory = document.getElementById('evolutionHistory');
            const turnIndicator = document.getElementById('turnIndicator');
            const evolveBtn = document.getElementById('evolveBtn');
            const newGameBtn = document.getElementById('newGameBtn');
            const generationCounter = document.getElementById('generationCounter');
            const evolutionProgress = document.getElementById('evolutionProgress');
            
            // Piece types and their base attributes
            const pieceTypes = {
                pawn: { symbol: '♟', baseMove: 1, baseCapture: 1, baseDefense: 1 },
                rook: { symbol: '♜', baseMove: 5, baseCapture: 4, baseDefense: 3 },
                knight: { symbol: '♞', baseMove: 3, baseCapture: 3, baseDefense: 2 },
                bishop: { symbol: '♝', baseMove: 4, baseCapture: 3, baseDefense: 2 },
                queen: { symbol: '♛', baseMove: 8, baseCapture: 7, baseDefense: 5 },
                king: { symbol: '♚', baseMove: 1, baseCapture: 2, baseDefense: 6 }
            };
            
            // Initialize the chess board
            function initializeBoard() {
                board.innerHTML = '';
                moveCount = 0;
                currentTurn = 'white';
                selectedPiece = null;
                validMoves = [];
                updateEvolutionProgress();
                
                // Create board cells
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const cell = document.createElement('div');
                        cell.className = `cell ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.addEventListener('click', handleCellClick);
                        board.appendChild(cell);
                    }
                }
                
                // Place pieces
                placePieces();
                updateTurnIndicator();
            }
            
            // Place pieces in their starting positions
            function placePieces() {
                // Piece setup order: rook, knight, bishop, queen, king, bishop, knight, rook
                const setupOrder = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
                
                // Place pawns
                for (let col = 0; col < 8; col++) {
                    createPiece('pawn', 'black', 1, col);
                    createPiece('pawn', 'white', 6, col);
                }
                
                // Place other pieces
                for (let col = 0; col < 8; col++) {
                    createPiece(setupOrder[col], 'black', 0, col);
                    createPiece(setupOrder[col], 'white', 7, col);
                }
            }
            
            // Create a piece with attributes
            function createPiece(type, color, row, col) {
                const cell = getCellAt(row, col);
                if (!cell) return;
                
                const piece = document.createElement('div');
                piece.className = `piece ${color}`;
                piece.dataset.type = type;
                piece.dataset.color = color;
                
                // Set base attributes with slight random variation
                const baseAttributes = pieceTypes[type];
                piece.dataset.move = baseAttributes.baseMove + getRandomVariation(0.2);
                piece.dataset.capture = baseAttributes.baseCapture + getRandomVariation(0.2);
                piece.dataset.defense = baseAttributes.baseDefense + getRandomVariation(0.2);
                
                // Add fitness score (evolutionary potential)
                piece.dataset.fitness = Math.round(Math.random() * 5 + 5);
                
                // Visual representation
                piece.textContent = color === 'white' 
                    ? baseAttributes.symbol.replace(/♟|♜|♞|♝|♛|♚/g, char => String.fromCharCode(char.charCodeAt(0) - 6))
                    : baseAttributes.symbol;
                
                // Add stats indicator
                const stats = document.createElement('div');
                stats.className = 'piece-stats';
                stats.textContent = piece.dataset.fitness;
                piece.appendChild(stats);
                
                cell.appendChild(piece);
            }
            
            // Get a small random variation
            function getRandomVariation(magnitude) {
                return Math.round((Math.random() * 2 - 1) * magnitude * 10) / 10;
            }
            
            // Get cell element at coordinates
            function getCellAt(row, col) {
                return document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            }
            
            // Handle cell click
            function handleCellClick(event) {
                const cell = event.currentTarget;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                // If a piece is already selected, try to move it
                if (selectedPiece) {
                    const targetCell = event.currentTarget;
                    const isValidMove = validMoves.some(move => 
                        move.row === parseInt(targetCell.dataset.row) && 
                        move.col === parseInt(targetCell.dataset.col)
                    );
                    
                    if (isValidMove) {
                        movePiece(selectedPiece, cell);
                    } else {
                        // If clicked on another piece of same color, select that piece instead
                        const piece = cell.querySelector('.piece');
                        if (piece && piece.dataset.color === currentTurn) {
                            clearSelection();
                            selectPiece(piece);
                        } else {
                            clearSelection();
                        }
                    }
                } else {
                    // Select a piece
                    const piece = cell.querySelector('.piece');
                    if (piece && piece.dataset.color === currentTurn) {
                        selectPiece(piece);
                    }
                }
            }
            
            // Select a piece and show its valid moves
            function selectPiece(piece) {
                selectedPiece = piece;
                const cell = piece.parentElement;
                cell.classList.add('selected');
                
                // Calculate and show valid moves
                calculateValidMoves(piece);
                
                // Show piece info
                displayPieceInfo(piece);
            }
            
            // Clear current selection
            function clearSelection() {
                if (selectedPiece) {
                    selectedPiece.parentElement.classList.remove('selected');
                    selectedPiece = null;
                }
                
                // Clear valid move indicators
                document.querySelectorAll('.valid-move').forEach(cell => {
                    cell.classList.remove('valid-move');
                });
                
                validMoves = [];
                pieceInfo.innerHTML = '<p>Select a piece to see its attributes</p>';
		document.querySelectorAll('.selected').forEach(cell => {
		    cell.classList.remove('selected');
		});
            }
            
            // Calculate valid moves for a piece
            function calculateValidMoves(piece) {
                const type = piece.dataset.type;
                const color = piece.dataset.color;
                const cell = piece.parentElement;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const moveRange = parseFloat(piece.dataset.move);
                
                validMoves = [];
                
                // Different move patterns based on piece type
                if (type === 'pawn') {
                    calculatePawnMoves(row, col, color, moveRange);
                } else if (type === 'knight') {
                    calculateKnightMoves(row, col, color, moveRange);
                } else if (type === 'bishop') {
                    calculateBishopMoves(row, col, color, moveRange);
                } else if (type === 'rook') {
                    calculateRookMoves(row, col, color, moveRange);
                } else if (type === 'queen') {
                    calculateQueenMoves(row, col, color, moveRange);
                } else if (type === 'king') {
                    calculateKingMoves(row, col, color, moveRange);
                }
                
                // Highlight valid moves
                validMoves.forEach(move => {
                    const moveCell = getCellAt(move.row, move.col);
                    if (moveCell) moveCell.classList.add('valid-move');
                });
            }
            
            // Calculate pawn moves
            function calculatePawnMoves(row, col, color, moveRange) {
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                
                // Forward movement
                let maxForward = Math.round(moveRange);
                if (row === startRow) maxForward = Math.max(2, maxForward); // Can move 2 from start
                
                for (let i = 1; i <= maxForward; i++) {
                    const newRow = row + (direction * i);
                    if (newRow < 0 || newRow > 7) break;
                    
                    const targetCell = getCellAt(newRow, col);
                    if (targetCell.querySelector('.piece')) break;
                    
                    validMoves.push({ row: newRow, col: col });
                }
                
                // Capture moves (diagonally)
                for (let colOffset of [-1, 1]) {
                    const newCol = col + colOffset;
                    if (newCol < 0 || newCol > 7) continue;
                    
                    const newRow = row + direction;
                    if (newRow < 0 || newRow > 7) continue;
                    
                    const targetCell = getCellAt(newRow, newCol);
                    const targetPiece = targetCell.querySelector('.piece');
                    
                    if (targetPiece && targetPiece.dataset.color !== color) {
                        validMoves.push({ row: newRow, col: newCol });
                    }
                }
            }
            
            // Calculate knight moves
            function calculateKnightMoves(row, col, color, moveRange) {
                const knightMoves = [
                    { row: -2, col: -1 }, { row: -2, col: 1 },
                    { row: -1, col: -2 }, { row: -1, col: 2 },
                    { row: 1, col: -2 }, { row: 1, col: 2 },
                    { row: 2, col: -1 }, { row: 2, col: 1 }
                ];
                
                // With evolved knights, we can have "extended" jump patterns
                const jumpExtension = Math.round(moveRange - 3);
                if (jumpExtension > 0) {
                    // Add extended jump patterns for evolved knights
                    for (let i = 1; i <= jumpExtension; i++) {
                        knightMoves.push(
                            { row: -2 - i, col: -1 }, { row: -2 - i, col: 1 },
                            { row: -1, col: -2 - i }, { row: -1, col: 2 + i },
                            { row: 1, col: -2 - i }, { row: 1, col: 2 + i },
                            { row: 2 + i, col: -1 }, { row: 2 + i, col: 1 }
                        );
                    }
                }
                
                for (const move of knightMoves) {
                    const newRow = row + move.row;
                    const newCol = col + move.col;
                    
                    if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) continue;
                    
                    const targetCell = getCellAt(newRow, newCol);
                    const targetPiece = targetCell.querySelector('.piece');
                    
                    if (!targetPiece || targetPiece.dataset.color !== color) {
                        validMoves.push({ row: newRow, col: newCol });
                    }
                }
            }
            
            // Calculate bishop moves
            function calculateBishopMoves(row, col, color, moveRange) {
                const directions = [
                    { row: -1, col: -1 }, { row: -1, col: 1 },
                    { row: 1, col: -1 }, { row: 1, col: 1 }
                ];
                
                for (const dir of directions) {
                    for (let i = 1; i <= Math.round(moveRange); i++) {
                        const newRow = row + (dir.row * i);
                        const newCol = col + (dir.col * i);
                        
                        if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
                        
                        const targetCell = getCellAt(newRow, newCol);
                        const targetPiece = targetCell.querySelector('.piece');
                        
                        if (!targetPiece) {
                            validMoves.push({ row: newRow, col: newCol });
                        } else {
                            if (targetPiece.dataset.color !== color) {
                                validMoves.push({ row: newRow, col: newCol });
                            }
                            break;
                        }
                    }
                }
            }
            
            // Calculate rook moves
            function calculateRookMoves(row, col, color, moveRange) {
                const directions = [
                    { row: -1, col: 0 }, { row: 1, col: 0 },
                    { row: 0, col: -1 }, { row: 0, col: 1 }
                ];
                
                for (const dir of directions) {
                    for (let i = 1; i <= Math.round(moveRange); i++) {
                        const newRow = row + (dir.row * i);
                        const newCol = col + (dir.col * i);
                        
                        if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
                        
                        const targetCell = getCellAt(newRow, newCol);
                        const targetPiece = targetCell.querySelector('.piece');
                        
                        if (!targetPiece) {
                            validMoves.push({ row: newRow, col: newCol });
                        } else {
                            if (targetPiece.dataset.color !== color) {
                                validMoves.push({ row: newRow, col: newCol });
                            }
                            break;
                        }
                    }
                }
            }
            
            // Calculate queen moves (combination of rook and bishop)
            function calculateQueenMoves(row, col, color, moveRange) {
                calculateRookMoves(row, col, color, moveRange);
                calculateBishopMoves(row, col, color, moveRange);
            }
            
            // Calculate king moves
            function calculateKingMoves(row, col, color, moveRange) {
                const directions = [
                    { row: -1, col: -1 }, { row: -1, col: 0 }, { row: -1, col: 1 },
                    { row: 0, col: -1 }, { row: 0, col: 1 },
                    { row: 1, col: -1 }, { row: 1, col: 0 }, { row: 1, col: 1 }
                ];
                
                // Kings can evolve to move slightly further
                const kingRange = Math.min(Math.round(moveRange), 2); // Cap at 2 for balance
                
                for (const dir of directions) {
                    for (let i = 1; i <= kingRange; i++) {
                        const newRow = row + (dir.row * i);
                        const newCol = col + (dir.col * i);
                        
                        if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) continue;
                        
                        const targetCell = getCellAt(newRow, newCol);
                        const targetPiece = targetCell.querySelector('.piece');
                        
                        if (!targetPiece || targetPiece.dataset.color !== color) {
                            validMoves.push({ row: newRow, col: newCol });
                        }
                        
                        // Kings can't move multiple spaces and capture
                        if (targetPiece) break;
                    }
                }
            }
            
            // Move a piece to a new cell
            function movePiece(piece, targetCell) {
                const sourceCell = piece.parentElement;
                const sourceRow = parseInt(sourceCell.dataset.row);
                const sourceCol = parseInt(sourceCell.dataset.col);
                const targetRow = parseInt(targetCell.dataset.row);
                const targetCol = parseInt(targetCell.dataset.col);
                
                // Handle captures
                const capturedPiece = targetCell.querySelector('.piece');
                if (capturedPiece) {
                    handleCapture(piece, capturedPiece);
                }
                
                // Move the piece
                targetCell.appendChild(piece);
                
                // Log the move
                logMove(piece, sourceRow, sourceCol, targetRow, targetCol, capturedPiece);
                
                // Switch turns
                currentTurn = currentTurn === 'white' ? 'black' : 'white';
                moveCount++;
                updateTurnIndicator();
                
                // Check if we should enable evolution
                if (moveCount % 10 === 0) {
                    evolveBtn.disabled = false;
                }
                
                // Update evolution progress bar
                updateEvolutionProgress();
                
                // Check for checkmate or game end
                checkGameEnd();
                

                // Clear selection
		sourceCell.classList.remove('selected');
                clearSelection();
            }
            
            // Handle piece capture and attribute transfer
            function handleCapture(attackingPiece, capturedPiece) {
                // Chance to absorb some attributes from captured piece
                const attackCapture = parseFloat(attackingPiece.dataset.capture);
                const defenderDefense = parseFloat(capturedPiece.dataset.defense);
                
                // Calculate capture success (higher attack vs defense improves chance)
                const captureAdvantage = attackCapture - defenderDefense;
                const baseAbsorbChance = 0.3; // 30% base chance
                const absorbChance = Math.min(0.8, Math.max(0.1, baseAbsorbChance + (captureAdvantage * 0.05)));
                
                // Potentially absorb some attributes
                if (Math.random() < absorbChance) {
                    // Choose a random attribute to improve
                    const attributes = ['move', 'capture', 'defense'];
                    const attributeToImprove = attributes[Math.floor(Math.random() * attributes.length)];
                    
                    // Calculate improvement (between 0.1 and 0.5)
                    const improvement = Math.round((Math.random() * 0.4 + 0.1) * 10) / 10;
                    
                    // Apply improvement
                    const currentValue = parseFloat(attackingPiece.dataset[attributeToImprove]);
                    attackingPiece.dataset[attributeToImprove] = Math.min(10, currentValue + improvement).toFixed(1);
                    
                    // Increase fitness
                    attackingPiece.dataset.fitness = Math.min(15, parseInt(attackingPiece.dataset.fitness) + 1);
                    attackingPiece.querySelector('.piece-stats').textContent = attackingPiece.dataset.fitness;
                    
                    // Log absorption
                    evolutionHistory.innerHTML = `<p>Piece ${attackingPiece.dataset.type} absorbed ${capturedPiece.dataset.type}'s traits and improved ${attributeToImprove} by ${improvement}!</p>` + evolutionHistory.innerHTML;
                }
                
                // Remove the captured piece
                capturedPiece.remove();
            }
            
            // Log move to game log
            function logMove(piece, fromRow, fromCol, toRow, toCol, capturedPiece) {
                const pieceType = piece.dataset.type;
                const pieceColor = piece.dataset.color;
                const fromSquare = String.fromCharCode(97 + fromCol) + (8 - fromRow);
                const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                
                let moveText = `${pieceColor[0].toUpperCase() + pieceColor.slice(1)} ${pieceType} moved from ${fromSquare} to ${toSquare}`;
                
                if (capturedPiece) {
                    moveText += ` capturing ${capturedPiece.dataset.color} ${capturedPiece.dataset.type}`;
                }
                
                gameLog.innerHTML = `<p>${moveText}</p>` + gameLog.innerHTML;
            }
            
            // Update the turn indicator
            function updateTurnIndicator() {
                turnIndicator.textContent = `${currentTurn[0].toUpperCase() + currentTurn.slice(1)}'s Turn`;
                turnIndicator.style.color = currentTurn === 'white' ? '#2c3e50' : '#000';
            }
            
            // Display piece information in the control panel
            function displayPieceInfo(piece) {
                const type = piece.dataset.type;
                const color = piece.dataset.color;
                const move = piece.dataset.move;
                const capture = piece.dataset.capture;
                const defense = piece.dataset.defense;
                const fitness = piece.dataset.fitness;
                
                pieceInfo.innerHTML = `
                    <h3>${color[0].toUpperCase() + color.slice(1)} ${type}</h3>
                    <p>Movement: ${move}</p>
                    <p>Capture: ${capture}</p>
                    <p>Defense: ${defense}</p>
                    <p>Fitness: ${fitness}</p>
                `;
            }
            
            // Check if the game has ended
            function checkGameEnd() {
                // Check if kings are still present
                const whiteKing = document.querySelector('.piece[data-type="king"][data-color="white"]');
                const blackKing = document.querySelector('.piece[data-type="king"][data-color="black"]');
                
                if (!whiteKing) {
                    gameLog.innerHTML = `<p>Game Over! Black wins by capturing the white king!</p>` + gameLog.innerHTML;
                    endGame('black');
                } else if (!blackKing) {
                    gameLog.innerHTML = `<p>Game Over! White wins by capturing the black king!</p>` + gameLog.innerHTML;
                    endGame('white');
		}
            }
            
            // End the game
            function endGame(winner) {
                // Disable further moves
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.removeEventListener('click', handleCellClick);
                });
                
                turnIndicator.textContent = `Game Over! ${winner[0].toUpperCase() + winner.slice(1)} wins!`;
                turnIndicator.style.color = winner === 'white' ? '#2c3e50' : '#000';
                
                // Disable evolution button
                evolveBtn.disabled = true;
            }
            
            // Update evolution progress bar
            function updateEvolutionProgress() {
                const progress = (moveCount % 10) * 10;
                evolutionProgress.style.width = `${progress}%`;
            }
            
            // Evolve pieces
            function evolvePieces() {
                // Increment generation counter
                generation++;
                generationCounter.textContent = generation;
                
                // Get all pieces and apply Fisherian runaway evolution
                const pieces = document.querySelectorAll('.piece');
                
                // Log start of evolution
                evolutionHistory.innerHTML = `<p>--- Generation ${generation} Evolution ---</p>` + evolutionHistory.innerHTML;
                
                pieces.forEach(piece => {
                    // Evolution chance based on fitness
                    const fitness = parseInt(piece.dataset.fitness);
                    const evolutionChance = Math.min(0.9, fitness * 0.05); // Max 90% chance
                    
                    if (Math.random() < evolutionChance) {
                        // Choose a random attribute to evolve
                        const attributes = ['move', 'capture', 'defense'];
                        const attributeToEvolve = attributes[Math.floor(Math.random() * attributes.length)];
                        
                        // Chance for Fisherian runaway effect (exaggerated growth)
                        const runawayChance = 0.25; // 25% chance for runaway
                        const isRunaway = Math.random() < runawayChance;
                        
                        // Calculate evolution
                        let evolutionMagnitude;
                        if (isRunaway) {
                            // Runaway evolution - larger boost
                            evolutionMagnitude = Math.round((Math.random() * 0.8 + 0.5) * 10) / 10;
                            
                            // Runaway effects have a chance to reduce other attributes
                            const otherAttributes = attributes.filter(attr => attr !== attributeToEvolve);
                            const tradeoffChance = 0.7; // 70% chance for tradeoff
                            
                            if (Math.random() < tradeoffChance) {
                                const tradeoffAttr = otherAttributes[Math.floor(Math.random() * otherAttributes.length)];
                                const reductionAmount = Math.round((Math.random() * 0.3 + 0.1) * 10) / 10;
                                const currentValue = parseFloat(piece.dataset[tradeoffAttr]);
                                
                                // Ensure it doesn't go below 0.5
                                piece.dataset[tradeoffAttr] = Math.max(0.5, currentValue - reductionAmount).toFixed(1);
                                
                                evolutionHistory.innerHTML = `<p>Tradeoff: ${piece.dataset.color} ${piece.dataset.type}'s ${tradeoffAttr} reduced by ${reductionAmount} to ${piece.dataset[tradeoffAttr]}!</p>` + evolutionHistory.innerHTML;
                            }
                        } else {
                            // Normal evolution - smaller boost
                            evolutionMagnitude = Math.round((Math.random() * 0.3 + 0.1) * 10) / 10;
                        }
                        
                        // Apply evolution
                        const currentValue = parseFloat(piece.dataset[attributeToEvolve]);
                        piece.dataset[attributeToEvolve] = Math.min(10, currentValue + evolutionMagnitude).toFixed(1);
                        
                        // Adjust fitness based on evolution
                        if (isRunaway) {
                            piece.dataset.fitness = Math.min(15, parseInt(piece.dataset.fitness) + 2);
                        } else {
                            piece.dataset.fitness = Math.min(15, parseInt(piece.dataset.fitness) + 1);
                        }
                        
                        // Update fitness display
                        piece.querySelector('.piece-stats').textContent = piece.dataset.fitness;
                        
                        // Log evolution
                        const evolutionType = isRunaway ? "RUNAWAY" : "normal";
                        evolutionHistory.innerHTML = `<p>${evolutionType} Evolution: ${piece.dataset.color} ${piece.dataset.type}'s ${attributeToEvolve} increased by ${evolutionMagnitude} to ${piece.dataset[attributeToEvolve]}!</p>` + evolutionHistory.innerHTML;
                    }
                });
                
                // Random mutation chance (completely new trait)
                const mutationChance = 0.15; // 15% chance
                if (Math.random() < mutationChance) {
                    // Select a random piece for mutation
                    const allPieces = Array.from(pieces);
                    const randomPiece = allPieces[Math.floor(Math.random() * allPieces.length)];
                    
                    // Special mutations
                    const mutations = [
                        {
                            name: "Knight-like Movement",
                            apply: function(piece) {
                                piece.dataset.specialMove = "knight";
                                return "can now make knight-like jumps in addition to normal moves";
                            }
                        },
                        {
                            name: "Diagonal Power",
                            apply: function(piece) {
                                piece.dataset.diagonalBoost = "1.5";
                                return "has increased power on diagonal moves";
                            }
                        },
                        {
                            name: "Capture Specialist",
                            apply: function(piece) {
                                piece.dataset.capture = Math.min(10, parseFloat(piece.dataset.capture) + 1.5).toFixed(1);
                                return `capture power boosted to ${piece.dataset.capture}`;
                            }
                        },
                        {
                            name: "Movement Master",
                            apply: function(piece) {
                                piece.dataset.move = Math.min(10, parseFloat(piece.dataset.move) + 1.5).toFixed(1);
                                return `movement range boosted to ${piece.dataset.move}`;
                            }
                        }
                    ];
                    
                    const randomMutation = mutations[Math.floor(Math.random() * mutations.length)];
                    const mutationResult = randomMutation.apply(randomPiece);
                    
                    // Log mutation
                    evolutionHistory.innerHTML = `<p>MUTATION: ${randomPiece.dataset.color} ${randomPiece.dataset.type} ${mutationResult}!</p>` + evolutionHistory.innerHTML;
                    
                    // Visual effect - add a star or glow to mutated piece
                    randomPiece.style.boxShadow = "0 0 10px gold";
                    setTimeout(() => {
                        randomPiece.style.boxShadow = "";
                    }, 3000);
                }
                
                // Reset evolution progress
                evolveBtn.disabled = true;
                evolutionProgress.style.width = "0%";
                
                // Log to game log
                gameLog.innerHTML = `<p>Pieces evolved! Generation ${generation} has begun.</p>` + gameLog.innerHTML;
            }
            
            // Event listeners
            newGameBtn.addEventListener('click', function() {
                initializeBoard();
                generation = 1;
                generationCounter.textContent = generation;
                evolutionHistory.innerHTML = '<p>Game started. Pieces have base attributes.</p>';
                gameLog.innerHTML = '<p>Game started. White to move.</p>';
            });
            
            evolveBtn.addEventListener('click', evolvePieces);
            
            // Initialize game on load
            initializeBoard();
        });
    </script>
</body>
</html>

