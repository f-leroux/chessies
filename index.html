<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Chess</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
            color: #333;
            padding: 20px;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .game-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            max-width: 1200px;
            justify-content: center;
        }

        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            border: 2px solid #333;
            margin-bottom: 10px;
        }

        .cell {
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            cursor: pointer;
            user-select: none;
        }

        .white {
            background-color: #f0d9b5;
        }

        .black {
            background-color: #b58863;
        }

        .selected {
            background-color: rgba(173, 216, 230, 0.7);
        }

        .valid-move::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: rgba(0, 128, 0, 0.5);
            border-radius: 50%;
            z-index: 1;
        }

        .piece {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .control-panel {
            width: 300px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .info-panel {
            width: 100%;
            max-width: 600px;
            margin-top: 20px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Simple Chess</h1>
    <div class="game-container">
        <div class="board-container">
            <div class="turn-indicator" id="turnIndicator">White's Turn</div>
            <div class="chess-board" id="chessBoard"></div>
        </div>

        <div class="control-panel">
            <h2>Control Panel</h2>
            <button id="newGameBtn">New Game</button>
        </div>
    </div>

    <div class="info-panel">
        <h2>Game Log</h2>
        <div class="game-log" id="gameLog">
            <p>Game started. White to move.</p>
        </div>

        <h2>How to Play</h2>
        <p>Click a piece to select it and click a highlighted square to move.</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let selectedPiece = null;
            let validMoves = [];
            let currentTurn = 'white';
            let moveCount = 0;

            const board = document.getElementById('chessBoard');
            const gameLog = document.getElementById('gameLog');
            const turnIndicator = document.getElementById('turnIndicator');
            const newGameBtn = document.getElementById('newGameBtn');

            const pieceSymbols = {
                pawn: '♟',
                rook: '♜',
                knight: '♞',
                bishop: '♝',
                queen: '♛',
                king: '♚'
            };

            function initializeBoard() {
                board.innerHTML = '';
                moveCount = 0;
                currentTurn = 'white';
                selectedPiece = null;
                validMoves = [];

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const cell = document.createElement('div');
                        cell.className = `cell ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.addEventListener('click', handleCellClick);
                        board.appendChild(cell);
                    }
                }

                placePieces();
                updateTurnIndicator();
            }

            function placePieces() {
                const setupOrder = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];

                for (let col = 0; col < 8; col++) {
                    createPiece('pawn', 'black', 1, col);
                    createPiece('pawn', 'white', 6, col);
                }

                for (let col = 0; col < 8; col++) {
                    createPiece(setupOrder[col], 'black', 0, col);
                    createPiece(setupOrder[col], 'white', 7, col);
                }
            }

            function createPiece(type, color, row, col) {
                const cell = getCellAt(row, col);
                if (!cell) return;

                const piece = document.createElement('div');
                piece.className = `piece ${color}`;
                piece.dataset.type = type;
                piece.dataset.color = color;

                const symbol = pieceSymbols[type];
                piece.textContent = color === 'white'
                    ? String.fromCharCode(symbol.charCodeAt(0) - 6)
                    : symbol;

                cell.appendChild(piece);
            }

            function getCellAt(row, col) {
                return document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            }

            function handleCellClick(event) {
                const cell = event.currentTarget;

                if (selectedPiece) {
                    const targetCell = event.currentTarget;
                    const isValidMove = validMoves.some(move =>
                        move.row === parseInt(targetCell.dataset.row) &&
                        move.col === parseInt(targetCell.dataset.col)
                    );

                    if (isValidMove) {
                        movePiece(selectedPiece, cell);
                    } else {
                        const piece = cell.querySelector('.piece');
                        if (piece && piece.dataset.color === currentTurn) {
                            clearSelection();
                            selectPiece(piece);
                        } else {
                            clearSelection();
                        }
                    }
                } else {
                    const piece = cell.querySelector('.piece');
                    if (piece && piece.dataset.color === currentTurn) {
                        selectPiece(piece);
                    }
                }
            }

            function selectPiece(piece) {
                selectedPiece = piece;
                const cell = piece.parentElement;
                cell.classList.add('selected');
                calculateValidMoves(piece);
            }

            function clearSelection() {
                if (selectedPiece) {
                    selectedPiece.parentElement.classList.remove('selected');
                    selectedPiece = null;
                }

                document.querySelectorAll('.valid-move').forEach(cell => {
                    cell.classList.remove('valid-move');
                });

                validMoves = [];
                document.querySelectorAll('.selected').forEach(cell => {
                    cell.classList.remove('selected');
                });
            }

            function calculateValidMoves(piece) {
                const type = piece.dataset.type;
                const color = piece.dataset.color;
                const cell = piece.parentElement;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                validMoves = [];

                if (type === 'pawn') {
                    calculatePawnMoves(row, col, color);
                } else if (type === 'knight') {
                    calculateKnightMoves(row, col, color);
                } else if (type === 'bishop') {
                    calculateBishopMoves(row, col, color);
                } else if (type === 'rook') {
                    calculateRookMoves(row, col, color);
                } else if (type === 'queen') {
                    calculateQueenMoves(row, col, color);
                } else if (type === 'king') {
                    calculateKingMoves(row, col, color);
                }

                validMoves.forEach(move => {
                    const moveCell = getCellAt(move.row, move.col);
                    if (moveCell) moveCell.classList.add('valid-move');
                });
            }

            function calculatePawnMoves(row, col, color) {
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;

                const newRow = row + direction;
                if (newRow >= 0 && newRow <= 7) {
                    const targetCell = getCellAt(newRow, col);
                    if (!targetCell.querySelector('.piece')) {
                        validMoves.push({ row: newRow, col: col });
                        if (row === startRow) {
                            const doubleRow = row + direction * 2;
                            const doubleCell = getCellAt(doubleRow, col);
                            if (doubleCell && !doubleCell.querySelector('.piece')) {
                                validMoves.push({ row: doubleRow, col: col });
                            }
                        }
                    }
                }

                [-1, 1].forEach(offset => {
                    const captureCol = col + offset;
                    const captureRow = row + direction;
                    if (captureCol >= 0 && captureCol <= 7 && captureRow >= 0 && captureRow <= 7) {
                        const targetCell = getCellAt(captureRow, captureCol);
                        const targetPiece = targetCell.querySelector('.piece');
                        if (targetPiece && targetPiece.dataset.color !== color) {
                            validMoves.push({ row: captureRow, col: captureCol });
                        }
                    }
                });
            }

            function calculateKnightMoves(row, col, color) {
                const knightMoves = [
                    { row: -2, col: -1 }, { row: -2, col: 1 },
                    { row: -1, col: -2 }, { row: -1, col: 2 },
                    { row: 1, col: -2 }, { row: 1, col: 2 },
                    { row: 2, col: -1 }, { row: 2, col: 1 }
                ];

                knightMoves.forEach(move => {
                    const newRow = row + move.row;
                    const newCol = col + move.col;

                    if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) return;

                    const targetCell = getCellAt(newRow, newCol);
                    const targetPiece = targetCell.querySelector('.piece');

                    if (!targetPiece || targetPiece.dataset.color !== color) {
                        validMoves.push({ row: newRow, col: newCol });
                    }
                });
            }

            function calculateBishopMoves(row, col, color) {
                const directions = [
                    { row: -1, col: -1 }, { row: -1, col: 1 },
                    { row: 1, col: -1 }, { row: 1, col: 1 }
                ];

                directions.forEach(dir => {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + dir.row * i;
                        const newCol = col + dir.col * i;
                        if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;

                        const targetCell = getCellAt(newRow, newCol);
                        const targetPiece = targetCell.querySelector('.piece');

                        if (!targetPiece) {
                            validMoves.push({ row: newRow, col: newCol });
                        } else {
                            if (targetPiece.dataset.color !== color) {
                                validMoves.push({ row: newRow, col: newCol });
                            }
                            break;
                        }
                    }
                });
            }

            function calculateRookMoves(row, col, color) {
                const directions = [
                    { row: -1, col: 0 }, { row: 1, col: 0 },
                    { row: 0, col: -1 }, { row: 0, col: 1 }
                ];

                directions.forEach(dir => {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + dir.row * i;
                        const newCol = col + dir.col * i;
                        if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;

                        const targetCell = getCellAt(newRow, newCol);
                        const targetPiece = targetCell.querySelector('.piece');

                        if (!targetPiece) {
                            validMoves.push({ row: newRow, col: newCol });
                        } else {
                            if (targetPiece.dataset.color !== color) {
                                validMoves.push({ row: newRow, col: newCol });
                            }
                            break;
                        }
                    }
                });
            }

            function calculateQueenMoves(row, col, color) {
                calculateRookMoves(row, col, color);
                calculateBishopMoves(row, col, color);
            }

            function calculateKingMoves(row, col, color) {
                const directions = [
                    { row: -1, col: -1 }, { row: -1, col: 0 }, { row: -1, col: 1 },
                    { row: 0, col: -1 }, { row: 0, col: 1 },
                    { row: 1, col: -1 }, { row: 1, col: 0 }, { row: 1, col: 1 }
                ];

                directions.forEach(dir => {
                    const newRow = row + dir.row;
                    const newCol = col + dir.col;
                    if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) return;

                    const targetCell = getCellAt(newRow, newCol);
                    const targetPiece = targetCell.querySelector('.piece');

                    if (!targetPiece || targetPiece.dataset.color !== color) {
                        validMoves.push({ row: newRow, col: newCol });
                    }
                });
            }

            function movePiece(piece, targetCell) {
                const sourceCell = piece.parentElement;
                const sourceRow = parseInt(sourceCell.dataset.row);
                const sourceCol = parseInt(sourceCell.dataset.col);
                const targetRow = parseInt(targetCell.dataset.row);
                const targetCol = parseInt(targetCell.dataset.col);

                const capturedPiece = targetCell.querySelector('.piece');
                if (capturedPiece) {
                    handleCapture(piece, capturedPiece);
                }

                targetCell.appendChild(piece);
                logMove(piece, sourceRow, sourceCol, targetRow, targetCol, capturedPiece);

                currentTurn = currentTurn === 'white' ? 'black' : 'white';
                moveCount++;
                updateTurnIndicator();
                checkGameEnd();

                sourceCell.classList.remove('selected');
                clearSelection();
            }

            function handleCapture(attackingPiece, capturedPiece) {
                capturedPiece.remove();
            }

            function logMove(piece, fromRow, fromCol, toRow, toCol, capturedPiece) {
                const pieceType = piece.dataset.type;
                const pieceColor = piece.dataset.color;
                const fromSquare = String.fromCharCode(97 + fromCol) + (8 - fromRow);
                const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);

                let moveText = `${pieceColor[0].toUpperCase() + pieceColor.slice(1)} ${pieceType} moved from ${fromSquare} to ${toSquare}`;
                if (capturedPiece) {
                    moveText += ` capturing ${capturedPiece.dataset.color} ${capturedPiece.dataset.type}`;
                }

                gameLog.innerHTML = `<p>${moveText}</p>` + gameLog.innerHTML;
            }

            function updateTurnIndicator() {
                turnIndicator.textContent = `${currentTurn[0].toUpperCase() + currentTurn.slice(1)}'s Turn`;
                turnIndicator.style.color = currentTurn === 'white' ? '#2c3e50' : '#000';
            }

            function checkGameEnd() {
                const whiteKing = document.querySelector('.piece[data-type="king"][data-color="white"]');
                const blackKing = document.querySelector('.piece[data-type="king"][data-color="black"]');

                if (!whiteKing) {
                    gameLog.innerHTML = `<p>Game Over! Black wins by capturing the white king!</p>` + gameLog.innerHTML;
                    endGame('black');
                } else if (!blackKing) {
                    gameLog.innerHTML = `<p>Game Over! White wins by capturing the black king!</p>` + gameLog.innerHTML;
                    endGame('white');
                }
            }

            function endGame(winner) {
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.removeEventListener('click', handleCellClick);
                });

                turnIndicator.textContent = `Game Over! ${winner[0].toUpperCase() + winner.slice(1)} wins!`;
                turnIndicator.style.color = winner === 'white' ? '#2c3e50' : '#000';
            }

            newGameBtn.addEventListener('click', function() {
                initializeBoard();
                gameLog.innerHTML = '<p>Game started. White to move.</p>';
            });

            initializeBoard();
        });
    </script>
</body>
</html>
